为什么函数式编程如此重要

摘要

随着软件工程演变得愈发复杂，把代码良好地组织起来越来越重要。
结构良好的代码易于开发和维护，并赋予我们丰富的模块以便重用，这对将来抑制编码所带来的负担十分有益。
在本篇论文中，我们来专门展示函数式编程的两大特性，高阶函数和惰性求值给模块化代码带来的重要意义。
作为示例，我们会操作列表和树，编写几个数字算法，并且实现一个字母启发式算法（人工智能领域用到的博弈程序所使用的一种算法）。
我们发现既然模块化是通过成功程序的钥匙，那么函数式编程更能助之锦上添花。

1. 引言
这篇论文是我向大众（非函数式）程序员展示函数式编程的意义的一次尝试，通过指明函数式的优势，帮助函数式程序员充分发掘潜力。

函数式编程之所以被这么称呼是因为它的基本操作就是对函数和参数的运用。
主程序本身作为一个函数接受程序输入作为参数，然后提交给程序输出作为结果。
主函数一般是由其他函数定义的，而其他函数则是由更多的函数定义的，一直延展到最底层定义的函数就是语言的原始类型。
函数式编程中函数的概念与数学函数中函数的概念十分类似，并且在此论文中会被看做等价的。
我们会遵循 Turner 的语言法则，不过为了照顾不具备函数式只是的读者会采用更加易读的表示方法。

函数式编程的主要特性和优点总结起来无非有如下几点。函数式程序没有赋值语句，因此变量一旦被赋值就不再改变。更确切地说，函数式程序完全没有副作用。调用一个函数除了能计算结果之外，不会造成任何影响。这消除了程序错误的一大来源，既然不存在副作用篡改表达式的值，代码的执行次序便不会对程序结果造成影响。这也减轻了程序员需要预测程序控制流的压力。既然表达式什么时候被计算对结果而言都无所谓，一个变量的值可以随意赋值给别的变量，反之亦然，这所体现出的，是程序的“引用透明”性。这种自由使得函数式代码从数学意义上比传统代码更加容易调试追踪。

这些对函数式概括的优点听上去不错，不过要是别人对此提不起兴趣，我们也不会感到诧异。前面叙述了一堆函数式编程没有什么（没有赋值、没有副作用、不用考虑控制流）却鲜有提及它究竟有什么。函数式程序员听上去就像中世纪的僧侣似的，站在道德的制高点上否认一切自己生命中对美好的追求。对大部分关注实际用途的人而言，这些所谓的优势无法令人信服。

函数式程序员反驳说他们掌握巨大的实际用途，他们比传统程序员具有极高的生产力，因为函数式程序员能写出极短的代码。为什么这么说呢？一个弱弱能站得住脚的关于这种优势的解释大概是传统程序包含 90% 的赋值语句，而函数式程序完全可以避免掉！但这显然太不合理了，要是避免复制语句能带来极大的便利，那么 FORTRAN 程序员早就已经这么干了二十年了。无论一门语言可能有多糟糕，要是仅仅因为能避免一些特性就变得强大，这从逻辑上也说不通。

即便是函数式程序员也不会满足于这种所谓的优势，因为这对于发挥函数式编程的潜力毫无用处。没人能写出完全没有赋值语句或者完全引用透明的程序。衡量代码质量的标准并不存在，所以争论这些并没有意义。

显然这些针对函数式的特征并不准确。我们必须找到一种东西来帮我们纠正误区 —— 既能解释函数式编程的能力，又能精确表达函数式编程致力于的方向。

2. 与结构化编程类比

将函数式编程与结构化编程对比十分有用。以往，结构化编程的优势总结起来无非有如下几点。结构化程序没有 goto 语句。结构化代码块只有一个入口和出口，结构化程序比非结构化程序更容易被追踪。结构化程序的这些优势与我们之前讨论的函数式程序的优势十分相似。

回头看结构结构化程序的这些属性，无可置疑这些都十分有用，但仍没有戳中核心要点。结构化程序和非结构化程序最大的区别在于结构化程序采用模块化设计。模块化设计给生产力带来巨大提升。首先而言，小模块很容易被快速编写出来。其次，通用模块可以被重用，这使得产品得以快速迭代。再之，模块可以被拿出来单独调试，有利于节省调试时间。

废除 goto 等等对于结构化程序毫无影响，它有助于“小规模开发”，而模块化设计有助于“大规模开发”。因此我们可以得益于结构化编程在 FORTRAN 或汇编语言中的实践，即使这样稍稍需要多做一些工作。

目前模块化设计普遍被认为是编写成功程序的重要因素，最近问世的一些语言例如 MODULA-II 和 Ada 都特意针对模块化做了改进。然而这其中有一个经常被遗忘的因素，当编写模块化程序解决问题时，我们首先把问题分解成子问题求解，然后解决这些子问题后组合结果。我们对原始问题进行分解的方法完全取决于我们能否组合分治后的结果。因此，为了提升我们模块化求解问题的能力，必须寻找组合问题的新方法。复杂的作用域规则和提供分散编译仅能解决表面问题 —— 他们无法对模块化进程做出重大贡献。

我们在这篇论文中着重留意函数式语言提供的两个全新的、重要的组合胶水。我们会给出一些例子来演示采用新的方法进行模块化设计可以做到更加简化。这是函数式编程最终要的能力 —— 它支持进一步层次的模块化。这也是函数式程序员致力于的方向 —— 更加简单而精悍的通用模块，组合起来以后用我们描述的方式继续互相组合。

3. 将函数组合起来

两种组合方式的第一种将小函数组合成稍复杂的函数。用列表处理算法来描述它 —— 给列表添加一个元素。我们这样定义一个数组

listof * ::= Nil | Cons * (listof *)

这意味着一个包含 *（不管 * 是什么）的列表要么是 Nil 表示空列表，要么是带有一个 * 的 Cons 跟着另一个包含 * 的列表。一个 Cons 代表一个首元素为 *，后续元素来自另一个列表的列表。此处的 * 代表任何元素 —— 例如，如果 * 是“整数”那么此处的定义就是一个整数列表要么为空，要么是一个包含一个数字和另一个整数列表的列表。基于惯例，我们用方括号写法代表列表和元素，而不是直接采用 Conses 和 Nils 的写法，这纯粹是为了注记方便。例如

[]      意思是 Nil
[1]     意思是 Cons 1 Nil
[1,2,3] 意思是 Cons 1 (Cons2 (Cons 3 Nil))

列表的元素可以被递归函数 sum 求和。 sum 函数必须被定义为接受两种类型的参数：空列表（Nil）和 Cons。因为空元素的和为 0，所以我们定义

sum Nil = 0

且因为 Cons 的和可以被定义为第一个元素和剩余列表元素的和，所以我们定义

sum (Cons n list) = num + sum list

回顾定义，我们发现只有下述花括号部分执行了求和运算。

sum Nil = {0}
sum (Cons n list) = n {+} sum list

这意味着求和运算可以组合通过一个递归模式和花括号的部分来实现模块化。这个递归模式通常被称作 foldr，因此 sum 可以被表示为

sum = foldr {+} 0

可以基于 sum 的定义给出 foldr 的定义，给出

(foldr f x) Nil = x
(foldr f x) (Cons a l) = f a ((foldr f x) l)

这里我们用括括号包裹住 (foldr f x) 使之明确表达替代 sum 的作用。不过一般来说括号都将被忽略，因此 ((foldr f x) l) 可以写作 (foldr f x l)。类似 foldr 这样带有三个参数的函数，实际上只处理了前两个参数，然后返回一个函数，再用这个新函数处理剩余的一个参数。推广到一般情况，一个带有 n 个参数的函数只处理前 m (m < n) 项，剩余的 n - m 项交由函数返回值处理。后续我们将沿用这一规则。

拥有这样一个模块化的 sum 函数，我们可以从局部获益。最有趣的部分就是 foldr 函数，它可以用来创造合并列表元素的新函数以作他用：

product = foldr (*) 1

也可以用来检测布尔列表是否包含真值

anytrue = foldr(∨) False

抑或是否全为真值

alltrue = foldr (∧) True

一种理解 (foldr f a) 是一个函数的方式是它用 f 来替换里表中所有的 Cons，以及用 a 替换所有的 Nil。以 [1,2,3] 这个列表为例，因为它等价于

Cons 1 (Cons 2 (Cons 3 Nil))

所以 (foldr (+) 0) 将它转换成

(+) 1 ((+) 2 (+) 3 0) = 6

然后 (foldr (*) 1) 将它转换成

(∗) 1 ((∗) 2 ((∗) 3 1)) = 6

现在看来 (foldr Cons Nil ) 很明显只是复制一个列表。既然一个列表可以通过构建 Cons 首元素然后追加在后面，我们发现

append a b = foldr Cons b a

举一个例子

append [1, 2] [3, 4] = foldr Cons [3, 4] [1, 2]
                     = foldr Cons [3, 4] (Cons 1 (Cons 2 Nil ))
                     = Cons 1 (Cons 2 [3, 4]))
                          (replacing Cons by Cons and Nil by [3, 4])
                     = [1,2,3,4]

我们可以用 length 函数求列表长度，由如下定义

length = foldr count 0
count a n = n + 1

因为 count 函数随着有多少个 Cons 就从 0 开始递增几次，一个使列表函数加倍的函数可以这么写

doubleall = foldr doubleandcons Nil

上述

doubleandcons n list = Cons (2 ∗ n) list

又因为

fandcons f = Cons . f

这里 “.”（组合函数符，一个标准操作符） 定义为

(f . g) h = f (g h)

我们得到一个两参的 fandcons 函数的正确定义：


fandconsf el = (Cons.f)el
             = Cons (f el)

所以

fandcons f el list = Cons (f el) list

最终结果是

doubleall = foldr (Cons . double) Nil

不采用模块化我们得到

doubleall = map double
mapf = foldr (Cons . f) Nil

上述 map 函数 —— 另一个常用函数 —— 用函数 f 处理列表中的所有元素。

我们甚至可以编写一个矩阵求和函数，矩阵表示列表的列表。如下

summatrix = sum . map sum

map sum 函数使用 sum 对行进行求和，然后最左侧的 sum 对求和后的列进行求和，从而得到整个矩阵的和。

这些例子足以说服读者了，即便是对模块化的一点应用，便可创造长远的价值。通过一个简单的模块化函数 (sum) 组合 “高阶函数” 和几个简单参数，我们无需付出诸多编程便得到了可以处理列表的其他函数（foldr）。

函数式编程不仅仅处理列表。接下来的例子，请看一颗排序树，给出如下定义

treeof * ::= Node * (listof (treeof *))

上述定义是一个由节点元素 * 组成的树，节点的内容以 * 作为标签注明，每个节点都包含一颗与父节点同样定义的子树。例如，如下这棵树

【这里有个图】

可以被表示为

Node 1
    (Cons (Node 2 Nil )
        (Cons (Node 3
            (Cons (Node 4 Nil ) Nil ))
        Nil ))

我们将直接采用一个与 foldr 类似的 foldtree 函数，而不打算用复杂抽象的高阶函数来举例。回想一下 foldr 函数接受两个参数的场景：有东西负责替换 Cons 且有东西负责替换 Nil。既然树也是用 Node、Cons 和 Nil 构建的，foldtree 必定需要接受三个参数 —— 用来逐一替换这些。所以我们定义

foldtree f g a (Node label subtrees) =
    f label (foldtree f g a subtrees)
foldtree f g a (Cons subtree rest) =
    g (foldtree f g a subtree) (foldtree f g a rest)
foldtreef gaNil = a

许多有趣的函数可以通过组合 foldtree 和其他函数实现。例如，树中所有数字标记元素
的可以这样子求和

sumtree = foldtree (+) (+) 0

继续以上述的树为例，sumtree 得到

(+) 1
    ((+) ((+) 2 0)
        ((+) ((+) 3
                ((+) ((+) 4 0) 0))
            0))
= 10

一列树中标签可以这样计算

labels = foldtree Cons append Nil

上例得到

Cons 1
    (append (Cons 2 Nil )
        (append (Cons 3
                (append (Cons 4 Nil ) Nil ))
            Nil ))
= [1,2,3,4]

最后，我们可以定义一个与 map 函数类似的函数，接受一个函数 f 来处理树中所有的标签：

maptree f = foldtree (Node . f ) Cons Nil

之所以能够这样实现，是因为相对于传统编程方式，函数式编程把函数当做最基本单元，然后将这些细小的部分 —— 高阶函数和其他一些特殊函数，进行组合。一旦被创造出来，这些高阶函数就可以方便地被拿来编程。无论面对什么新的数据结构，高阶函数都可以轻易被创造出来处理它。这使得操纵数据结构十分方便，也使得关注点更加集中在表现形式上。与传统编程想对比最好的例子就是语言的可拓展性 —— 就作用而言，这门编程语言可以随意按需拓展出新的控制结构。
